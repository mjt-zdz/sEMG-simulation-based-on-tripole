from MU import MotorUnit
import numpy as np
import matplotlib.pyplot as plt
import random
import scipy.io
from matplotlib.ticker import NullFormatter
# plt.rcParams['font.family'] = 'Times New Roman'

class SurfaceEMG():
    """
    A class that represnts a surface EMG (sEMG).
    表面肌电信号类
    Methods:
        simulate_recruitment_model()
            -Simulates the motor unit recruitment with firing patterns on increasing the number of muscle fibres per motor unit.
            -通过增加每个运动单元中的肌纤维数量，模拟运动单元的招募及放电模式
        caculate_surface_emg()
            -Simulates the surface electromyography signal generated by the motor unit recruitment.
            -模拟通过运动单元招募生成的表面肌电信号
        simulate_surface_emg()
            -Adds noise to the simulated surface electromyography
            -模拟表面肌电信号中添加噪声
    
    Attributes:
        signal_to_noise_rate:
            -float, dB, Signal to noise ratio for Gaussian noise. SNR = inf returns EMG without noise.
            -信噪比（高斯噪声），SNR为无穷大时不添加噪声
        signal_amplitude_offset
            -float, mV, Add a value for signal amplitude offset from 0.
            -信号振幅的基线值，用于调整信号基线，避免负值或改善信号的可测量性
        maximum_number_of_motor_units
            -int, The maximum number of motor units to calculate the motor unit radius and number of fibre for each motor unit. 
            -最大运动单元数量，用于计算运动单元半径和每个运动单元中的肌纤维数量
        motor_unit_depth
            -int, mm
            -运动单元距离电极的深度
          
    For simulate_recruitment_model:
        simulation_time: 
            -int, s, Entire duration of the simulation.
            -总模拟时长
        ramp: 
            -np.array, s, Excitatory drive function in a trapeziod shape (ramp-up, stable, ramp-down times).
            -上升、稳定、下降的时间
        sampling_rate: 
            -int, Hz, Sampling frequency of the simulation.
            -采样频率
        maximum_excitation_level: 
            -int, Maximum excitation level of motor unit.
            -最大激发水平
        number_of_motor_units: 
            -int, Number of motoneurons in the pool. Total number of motor units in the simulation.
            -池中运动神经元的数量
        recruitment_range: 
            -int, The desired maximum for the range of recruitment threshold values.
            -招募阈值范围的最大值
        excitatory_gain:
            -int, pps/10% MVC, The gain of the excitatory drive-firing rate relationship, 3 pps per 10% MVC => 0.3 Hz per % MVC.
            -兴奋性驱动-放电率关系的增益系数
        minimum_firing_rate: 
            -int, Hz, Minimum firing rate.
            -最小放电率
        peak_firing_rate_first_unit: 
            -int, Hz, Peak firing rate of the first motoneuron.
            -第一个运动单元的峰值放电率
        peak_firing_rate_difference: 
            -int, Hz, Desired difference in peak firing rates between the first and last motor units.
            -第一个和最后一个运动单元的峰值放电率差值
        inter_spike_interval_coefficient_variation: 
            -int, The inter spike interval variance coefficient.
            -峰间间隔的变异系数
        
    For simulate_surface_emg:
        twitch_force_range: 
            -int, The range of twitch forces RP (force units), largest/smallest.
            -抽搐力量【短暂的单次收缩过程中产生的力量】的范围（最大/最小），1单位力=最小运动单元的抽搐力
        motor_unit_density: 
            -int, fibres/mm^2, The motor-unit fibre density.
            -运动单元中的肌纤维密度
        smallest_motor_unit_number_of_fibres: 
            -int, Number of fibres innervated by the smallest motor unit.
            -最小运动单元支配的肌纤维数量
        largest_motor_unit_number_of_fibres: 
            -int, Number of fibres innervated by the largest motor unit.
            -最大运动单元支配的肌纤维数量
        muscle_fibre_diameter: 
            -float, mm, The muscle-fibre diameter.
            -肌纤维直径
        muscle_cross_sectional_diameter: 
            -int, mm, The muscle cross-sectional diameter.
            -肌肉截面直径
        electrodes_in_z: 
            -int, Number of elecrodes in the array, in the direction of the fibre.
            -阵列中沿肌纤维方向的电极数量
        electrodes_in_x: 
            -int, Number of electrodes in the array across the fibre.
            -阵列中横跨肌纤维方向的电极数量
    
    For plotting methods:
        y_limit_minimum: 
            -Minimum value of plot y-axis.
            -y轴的最小值
        y_limit_maximum: 
            -Maximum value of plot y-axis.
            -y轴的最大值
    """


    def __init__(self, simulation_time=30, ramp=[5, 20, 5], sampling_rate=10000, maximum_excitation_level=20, signal_to_noise_ratio=float('inf'), signal_amplitude_offset=0, 
                 number_of_motor_units=200, recruitment_range=30, excitatory_gain=3, minimum_firing_rate=8, peak_firing_rate_first_unit=35, 
                 peak_firing_rate_difference=10, inter_spike_interval_coefficient_variation=0.15, conduction_velocity_min_value=3.5, conduction_velocity_max_value=4.5, 
                 twitch_force_range=100, motor_unit_density=20, smallest_motor_unit_number_of_fibres=25, largest_motor_unit_number_of_fibres=2725, 
                 muscle_fibre_diameter=46e-3, muscle_cross_sectional_diameter=15, maximum_number_of_motor_units=200, motor_unit_depth = 10,
                 electrodes_in_z=14, electrodes_in_x=9): 
        """
        Initializes a new sEMG object.
        初始化一个新的sEMG三对象
        """
        ### Sampling parameters 
        self.simulation_time = simulation_time # Total simulation time in seconds.
        self.ramp = ramp # Up, stable, and down times of the ramp in seconds.
        self.sampling_rate = sampling_rate # Sampling rate.
        self.maximum_excitation_level = maximum_excitation_level # Maximum excitation level as a percentage of maximum.
        self.signal_to_noise_ratio = signal_to_noise_ratio # Signal to noise ratio for Gaussian noise. SNR = inf returns EMG without noise.
        self.signal_amplitude_offset = signal_amplitude_offset # Add a value for signal amplitude offset.
        
        ### Motorneuron parameters
        self.number_of_motor_units = number_of_motor_units # Number of motoneurons (units) in the pool.
        self.recruitment_range = recruitment_range # Range of recruitment threshold values, the largest.
        self.excitatory_gain = excitatory_gain # Gain of the excitatory drive-firing rate relationship, 3 pps per 10% MVC => 0.3 Hz per % MVC.
        self.minimum_firing_rate = minimum_firing_rate # Minumum firing rate.
        self.peak_firing_rate_first_unit = peak_firing_rate_first_unit # Peak firing rate of the first motoneuron.
        self.peak_firing_rate_difference = peak_firing_rate_difference # Desired difference in peak firing rates between the first and last MUs.
        self.inter_spike_interval_coefficient_variation = inter_spike_interval_coefficient_variation # The inter spike interval variance coefficient.
        self.conduction_velocity_min_value = conduction_velocity_min_value # The minimum conduction velocity.
        self.conduction_velocity_max_value = conduction_velocity_max_value # The maximum conduction velocity.
  
        ### Number of fibres parameters
        self.twitch_force_range = twitch_force_range # The range of twitch forces RP (force units), the largest.
        self.motor_unit_density = motor_unit_density  # The fibre density of motor unit.
        self.smallest_motor_unit_number_of_fibres = smallest_motor_unit_number_of_fibres # Number of fibres innervated by the smallest MU.
        self.largest_motor_unit_number_of_fibres = largest_motor_unit_number_of_fibres # Number of fibres innervated by the largest MU.
        self.muscle_fibre_diameter = muscle_fibre_diameter # The muscle-fibre diameter.
        self.muscle_cross_sectional_diameter = muscle_cross_sectional_diameter # The muscle cross-sectional diameter.
        self.maximum_number_of_motor_units = maximum_number_of_motor_units # The maximum number of MUs to calculate the MU radius and number of fibre for each MU. 
        self.motor_unit_depth = motor_unit_depth # (mm)
                
        self.electrodes_in_z = electrodes_in_z # Number of electrodes in the z-direction.
        self.electrodes_in_x = electrodes_in_x # Number of electrodes in the x-direction.
    
    def init_plot_parameters(self, y_limit_minimum=-1, y_limit_maximum=1, simulations=[], time_start=0, time_end=10, 
                              amplitude_start=-20, amplitude_end=60):
        
        self.y_limit_minimum = y_limit_minimum # Minimum value of plot y-axis.
        self.y_limit_maximum = y_limit_maximum # Maximum value of plot y-axis
        self.simulations = simulations # Empty list for simulation.
        self.time_start = time_start # (s)
        self.time_end = time_end # (s)
        self.amplitude_start = amplitude_start # (mV)
        self.amplitude_end = amplitude_end # (mV)
        
    #########################  1  #########################  Simulate Recruitment Model ##########################    #######################
    def simulate_recruitment_model(self):
        """
        Generates the recruitment and rate coding organization of motor units.
        生成MU招募和放电编码（MUSTs）
    
        Arguments:
        According to Models of Recruitment and Rate Coding Organization in Motor-Unit Pools. Fuglevand, et al 1993.
        simulation_time: 
            -int, s, Entire duration of the simulation.
            -总模拟时长
        ramp: 
            -np.array, s, Excitatory drive function in a trapeziod shape (ramp-up, stable, ramp-down times).
            -上升、稳定、下降的时间
        sampling_rate: 
            -int, Hz, Sampling frequency of the simulation.
            -采样频率
        maximum_excitation_level: 
            -int, Maximum excitation level of motor unit.
            -最大激发水平
        number_of_motor_units: 
            -int, Number of motoneurons in the pool. Total number of motor units in the simulation.
            -池中运动神经元的数量
        recruitment_range: 
            -int, The desired maximum for the range of recruitment threshold values.
            -招募阈值范围的最大值
        excitatory_gain:
            -int, pps/10% MVC, The gain of the excitatory drive-firing rate relationship, 3 pps per 10% MVC => 0.3 Hz per % MVC.
            -兴奋性驱动-放电率关系的增益系数
        minimum_firing_rate: 
            -int, Hz, Minimum firing rate.
            -最小放电率
        peak_firing_rate_first_unit: 
            -int, Hz, Peak firing rate of the first motoneuron.
            -第一个运动单元的峰值放电率
        peak_firing_rate_difference: 
            -int, Hz, Desired difference in peak firing rates between the first and last motor units.
            -第一个和最后一个运动单元的峰值放电率差值
        inter_spike_interval_coefficient_variation: 
            -int, The inter spike interval variance coefficient.
            -峰间间隔的变异系数
    
        Returns:
            A list containing firing time arrays for each motor unit.
            一个包含每个MU放电时间数组的列表
        """

        ### arguments
        simulation_time = self.simulation_time
        ramp = self.ramp
        sampling_rate = self.sampling_rate
        maximum_excitation_level = self.maximum_excitation_level
        number_of_motor_units = self.number_of_motor_units
        recruitment_range = self.recruitment_range
        excitatory_gain = self.excitatory_gain
        peak_firing_rate_first_unit = self.peak_firing_rate_first_unit
        peak_firing_rate_difference = self.peak_firing_rate_difference
        minimum_firing_rate = self.minimum_firing_rate
        inter_spike_interval_coefficient_variation = self.inter_spike_interval_coefficient_variation 
        
        ### Time vector
        time_array = np.linspace(0, simulation_time, simulation_time*sampling_rate)
        self.time_array = time_array
        
        ### Calculate the recruitment threshold excitation. Equation (1) in Fuglevand 1993.
        ### 计算MU的招募阈值激发(激活特定运动单元所需的最低神经兴奋水平)
        a = (np.log(recruitment_range) / number_of_motor_units) # Constant related to eq. (1).
        recruitment_threshold_excitation = np.exp(a*(np.arange(1, number_of_motor_units + 1, 1)))
        
        ### Calculate the peak firing rate for each motoneuron. Equation (5) in Fuglevand 1993.
        peak_firing_rate_i = peak_firing_rate_first_unit - peak_firing_rate_difference * (recruitment_threshold_excitation / recruitment_threshold_excitation[-1])
        
        ### Calculate the maximum excitation. Equation (8) in Fuglevand 1993.
        maximum_excitation = recruitment_threshold_excitation[-1] + (peak_firing_rate_i[-1] - minimum_firing_rate) / excitatory_gain
        
        ### Define the excitatory drive function.
        excitatory_drive_function = np.concatenate((np.linspace(0, maximum_excitation * (maximum_excitation_level/100), ramp[0] * sampling_rate), np.ones(ramp[1] * sampling_rate) * maximum_excitation * (maximum_excitation_level/100), (np.flip(np.linspace(0, maximum_excitation * (maximum_excitation_level/100),ramp[2] * sampling_rate)))))
        
        ### Initialize the firing times for each motoneuron.
        firing_times_motor_unit = [[] for i in range(number_of_motor_units)]
        
        # iteration_variableate over each motoneuron.
        for i in range(number_of_motor_units):
            # Calculate the thresholded excitatory drive.
            excitatory_drive_threshold = excitatory_drive_function - recruitment_threshold_excitation[i]
        
            # Find the samples that are associated with firing. Above this thresh => fire
            find_excitatory_drive_threshold = np.where(excitatory_drive_threshold >= 0)[0]
        
            # If there are no samples associated with firing, continue.
            if len(find_excitatory_drive_threshold) == 0:
                continue
        
            # Calculate the time of the first impulse.
            firing_times_motor_unit[i].append(time_array[find_excitatory_drive_threshold[0]])
            #firing_times_motor_unit[i] = np.append(firing_times_motor_unit[i], time_array[find_excitatory_drive_threshold[0]])
        
            # Calculate points of exceeded threshold 
            excitation_difference = excitatory_drive_threshold[find_excitatory_drive_threshold[0]]
          
            # Time point for the first impulse 
            time_instance = firing_times_motor_unit[i][0]
        
            # Initialize the firing counter.
            iteration_variable = 0
        
            ## Iterate until the current time is greater than the last sample point associated with firing.
            while time_instance <= time_array[find_excitatory_drive_threshold[-1]]:
                # Calculate the inter spike interval.
                inter_spike_interval = max(1 / (excitatory_gain * excitation_difference + minimum_firing_rate), 1 / peak_firing_rate_i[i])
            
                firing_times_motor_unit[i].append(firing_times_motor_unit[i][iteration_variable] + (inter_spike_interval_coefficient_variation * inter_spike_interval) * np.random.randn() + inter_spike_interval)
            
                # Update the firing counter.
                iteration_variable += 1
        
                # Find the minimum index of the sample point that is closest to the current firing time.
                minimum_time_index = np.argmin(np.abs(firing_times_motor_unit[i][iteration_variable] - time_array[find_excitatory_drive_threshold]))
        
                # Update the thresholded excitatory drive.
                excitation_difference = excitatory_drive_threshold[find_excitatory_drive_threshold[minimum_time_index]]
        
                # Update the current time.
                time_instance = firing_times_motor_unit[i][iteration_variable]
        
        # print('Firing Times for each Motor Unit', firing_times_motor_unit)
        scipy.io.savemat('recrtuitment_model' + '_' + str(number_of_motor_units) + 'MUs_' + str(sampling_rate) + 'fs'  + '.mat', {'spike_trains': firing_times_motor_unit, 'time_points': time_array})
        # scipy.io.savemat('time' + '.mat', {'time_points': time_array})
        
        self.firing_times_motor_unit = firing_times_motor_unit
        return firing_times_motor_unit
  
    #########################  2  #########################  Plot Recruitment Model  ##########################    #######################
    def plot_recruitment_model(self):
        """Plots the firing patterns of the motor unit recruitment.
    
        Arguments:
          firing_times_motor_unit
          time_array
    
        Returns:
          A plot of the recruitment model for each motor unit.
        """

        ### Default arguments:
            
        firing_times_motor_unit = self.firing_times_motor_unit # self.simulate_recruitment_model()
        time_array = self.time_array

        ### En lista med olika färger för varje motor enhet
        #colors = ['b', 'g', 'r', 'c', 'm', 'y', 'k']
        def generate_unique_colors(num_colors):
            unique_colors = set()
            colors = []

            while len(unique_colors) < num_colors:
                color = "#{:02X}{:02X}{:02X}".format(random.randint(0, 255), random.randint(0, 255), random.randint(0, 255))
                if color not in unique_colors:
                    unique_colors.add(color)
                    colors.append(color)
            return colors

        num_colors = self.number_of_motor_units  # Ange det önskade antalet unika färger här
        colors = generate_unique_colors(num_colors)

        ### Plot of the firing times motor unit
        plt.figure()
        for i, time_array in enumerate(firing_times_motor_unit):
            color = colors[i % len(colors)]  # Välj en färg från listan baserat på i
            for j in time_array:
                plt.plot([j, j], [i, i+1], color=color, label = f'Motor Unit {i + 1}')
        plt.ylim=(-0.5, 100)
                
        plt.xlabel('Time (s)', fontsize = 15)
        plt.ylabel('Motor Unit Number', fontsize = 15)
        plt.title('Firing Times of Motor Units', fontsize = 18, fontweight = 'bold')
        plt.grid(axis = 'both')
        
        number_of_motor_units = self.number_of_motor_units
        plt.tight_layout()
        # Set the desired resolution
        plt.savefig('recruitment_model_{}MUs.png'.format(number_of_motor_units), dpi = 600)
        
        return plt.show()
  
    #########################  3  #########################  Simulate Surface Electromyography  ##########################    #######################
    def caculate_surface_emg(self):
        """Simulates the surface electromyography based on the recruitment model.
    
        Arguments:
          firing_times_motor_unit
          time_array
          motor_unit_i
          twitch_force_range
          number_of_motor_units
          motor_unit_density
          smallest_motor_unit_number_of_fibres
          largest_motor_unit_number_of_fibres
          muscle_fibre_diameter
          muscle_cross_sectional_diameter
          electrodes_in_z
          electrodes_in_x
    
        Returns:
          A list containing an array with the simulated surface electromyography based on the recruitment model of each motor unit for all electrodes.
        """

        firing_times_motor_unit = self.simulate_recruitment_model()
        time_array = self.time_array
        motor_unit_i = MotorUnit()
        twitch_force_range = self.twitch_force_range
        number_of_motor_units = self.number_of_motor_units
        motor_unit_density = self.motor_unit_density
        smallest_motor_unit_number_of_fibres = self.smallest_motor_unit_number_of_fibres
        largest_motor_unit_number_of_fibres = self.largest_motor_unit_number_of_fibres
        muscle_fibre_diameter = self.muscle_fibre_diameter
        muscle_cross_sectional_diameter = self.muscle_cross_sectional_diameter
        electrodes_in_z = self.electrodes_in_z
        electrodes_in_x = self.electrodes_in_x
        max_number_of_motor_units = self.maximum_number_of_motor_units
        motor_unit_depth = self.motor_unit_depth
        conduction_velocity_min_value = self.conduction_velocity_min_value
        conduction_velocity_max_value = self.conduction_velocity_max_value
        
        ### Calculate the number of fibres innervated by each motor unit according to equation (21) Fuglevand et al 1993.
        # Calculate the peak twitch force for each unit accroding to equation (13) in Fuglevand 1993.
        b = (np.log(twitch_force_range) / max_number_of_motor_units) # Constant related to eq. (13).
        peak_twitch_force = np.exp(b*(np.arange(1, max_number_of_motor_units + 1, 1))) # Pi, where i = np.arange(1, number_of_motor_units + 1, 1)
        
        # The numbmer of muscle fibres required to exert one unit of force (1 unit force ≈ twitch force of smallest motor unit)
        total_peak_twitch_forces = np.sum(peak_twitch_force) # P_tot
        
        ## Calculate the total number of fibres (nf_tot) in a muscle, with a cross-sectional area (Am) and average area of a muscle fibre (Af). 
        # The muscle cross-sectional area (mm^2)
        Am = np.pi * (muscle_cross_sectional_diameter/2)**2 # Am
        
        # The muscle fibre average area (mm^2)
        Af = np.pi * (muscle_fibre_diameter/2)**2 # Af
        
        nf_tot = Am/Af # nf_tot 
        
        ## The number of fibres (nf_i) innervated by each motor unit according to equation (21) Fuglevand et al 1993.
        max_number_of_fibres = (nf_tot/total_peak_twitch_forces) * peak_twitch_force # nf_i
        if max_number_of_fibres[0] < smallest_motor_unit_number_of_fibres or max_number_of_fibres[-1] > largest_motor_unit_number_of_fibres:
            print('Default values have been changed')
        number_of_fibres_variation = max_number_of_fibres[0:number_of_motor_units]
        
        ### The area encompassed by each motor-unit territory (Ai), was then calculated from the unit fibre density according to equation (22) Fuglevand et al 1993
        motor_unit_area = number_of_fibres_variation/motor_unit_density # Ai
        
        # The motor unit radius variation calculated from its area (mm)
        max_motor_unit_radius = np.sqrt(motor_unit_area/np.pi)
        motor_unit_radius_variation = max_motor_unit_radius[0:number_of_motor_units]
        
        ### Calculate the motor unit depth variation that use to calcualte the fibre depth variation 
        eta_angle = 2 * np.pi * np.random.random(number_of_motor_units)
        
        x_position_motor_unit = np.zeros(number_of_motor_units)
        y_position_motor_unit = np.zeros(number_of_motor_units)
        # calculating coordinates
        for i in range(number_of_motor_units):
            radial_position_motor_unit = muscle_cross_sectional_diameter/2 * np.random.random()
            x_position_motor_unit[i] = radial_position_motor_unit * np.cos(eta_angle[i])
            y_position_motor_unit[i] = radial_position_motor_unit * np.sin(eta_angle[i])
        
        
        num_elements = number_of_motor_units
        # conduction_velocity_equal_steps = np.linspace(conduction_velocity_min_value, conduction_velocity_max_value, num_elements)
        conduction_velocity_random = np.random.uniform(conduction_velocity_min_value, conduction_velocity_max_value, num_elements)
        
        ### Calculate simuations of the surface EMG signal
        simulations = []
        muaps = []
        
        for m, element in enumerate(firing_times_motor_unit):
            motor_unit_i.number_of_fibres = int(number_of_fibres_variation[m])
            motor_unit_i.motor_unit_radius = motor_unit_radius_variation[m]
            motor_unit_i.motor_unit_depth = motor_unit_depth - y_position_motor_unit[m]
            motor_unit_i.motor_unit_x_position = x_position_motor_unit[m]
            motor_unit_i.conduction_velocity = conduction_velocity_random[m]
            motor_unit_i.number_of_electrodes_z = electrodes_in_z
            motor_unit_i.number_of_electrodes_x = electrodes_in_x
              
            current_motor_unit = motor_unit_i.simulate_motor_unit()
            muaps.append(current_motor_unit)
          # Add list of every motor unit in a long list.
            simulation = np.full((len(current_motor_unit), len(time_array)), current_motor_unit[0,0])
        
            for e in range(len(element)):
                # Find the time index where a firing occurs
                time_index = np.argmin(np.abs(time_array - element[e]))
                
                # Add the current motor unit to the simulation at the appropriate time index
                if simulation[:, time_index:time_index + current_motor_unit.shape[1]].shape >= current_motor_unit.shape:
                  simulation[:, time_index:time_index + current_motor_unit.shape[1]] += current_motor_unit
            
            simulations.append(simulation)
        self.simulations = np.sum(np.array(simulations), axis=0)
        self.muaps = muaps
        return self.muaps, self.simulations
    
    #########################  4  #########################   Adds Noise To The Simulation  ##########################    #######################
    def simulate_surface_emg(self):
        """Adds noise to the entire simulation.
    
        Arguments:
        simulations: simulate_surface_emg
    
        Returns:
          A list containing an array with the simulated surface electromyography with added noise.
        """

        signal_to_noise_ratio  = self.signal_to_noise_ratio
        # simulations = self.caculate_surface_emg()
        simulations = self.simulations
        time_array = self.time_array
        signal_amplitude_offset = self.signal_amplitude_offset
        number_of_electrodes_z = self.electrodes_in_z
        number_of_electrodes_x = self.electrodes_in_x
        time_start = self.time_start
        time_end = self.time_end
        amplitude_start = self.amplitude_start
        amplitude_end = self.amplitude_end
        number_of_motor_units = self.number_of_motor_units
        
        electrod_postion = number_of_electrodes_x * number_of_electrodes_z
        if signal_to_noise_ratio == float('inf'):
            return simulations
        
        else:
            noise_level = np.mean(simulations, axis=1) / (10**(signal_to_noise_ratio/20))*1000
            noise = signal_amplitude_offset + np.tile(noise_level, (simulations.shape[1],1)).T * np.random.normal(size = (electrod_postion, len(time_array)))
            
            signal_with_noise = simulations + noise
            
            self.simulations_with_noise = signal_with_noise      
        
        fig = plt.figure()
        plt.subplot(2,1,1)
        plt.plot(time_array, signal_with_noise[electrod_postion-1, :] * 10**3, label = 'sEMG with noise')
        plt.plot(time_array, self.simulations[electrod_postion-1, :] * 10**3, label = 'Original sEMG')
        plt.legend()
          
        plt.subplot(2,1,2)
        plt.plot(time_array, signal_with_noise[electrod_postion-1, :] * 10**3)
        plt.plot(time_array, self.simulations[electrod_postion-1, :] * 10**3)
        
        plt.xlim(time_start, time_end)
        plt.ylim(amplitude_start, amplitude_end)
        fig.supxlabel('Time (s)', fontsize = 15)
        fig.supylabel('Amplitude (mV)', fontsize = 15) # µ
        fig.suptitle('sEMG Signal with and without Noise', fontsize = 20, fontweight = 'bold')
          
        # Set the desired resolution
        plt.savefig('sEMG_with_and_without_noise_{}MUs_{}X{}.png'.format(number_of_motor_units,number_of_electrodes_z,number_of_electrodes_x), dpi = 600)
        plt.show()
        
        scipy.io.savemat('sEMG_without_Noise' + '_' + str(number_of_motor_units) + 'MUs_' + str(number_of_electrodes_z) + 'X' + str(number_of_electrodes_x)  + '.mat', {'output': -self.simulations})
        
        return signal_with_noise

    def plot_muap_array(self):
        """Plots the sEMG array without the added noise.
        
        Arguments:
          simulations
          time_array 
          y_limit_minimum
          y_limit_maximum
          number_of_electrodes_z
          number_of_electrodes_x
        
        Returns:
          Plot of surface EMG without noise
        """

        ### Default arguments:
        # simulations = self.caculate_surface_emg()
        simulations = self.muaps[10][:, :]
        time_length = MotorUnit().time_length
        delta_time = 0.1 # (10 kHz)
        time_array = np.arange(0, time_length + delta_time, delta_time)  
        y_limit_minimum = self.y_limit_minimum
        y_limit_maximum = self.y_limit_maximum
        number_of_electrodes_z = self.electrodes_in_z
        number_of_electrodes_x = self.electrodes_in_x
                
        ### Plot the normalized motor unit action potential
        normalized_simulation = simulations # electrode_sum
        normalized_simulation = (normalized_simulation - normalized_simulation.mean()) / (normalized_simulation.max() - normalized_simulation.min())
        
        # The single fibre action potentials recorded by the electrodes positioned along the length of the fibre.
        array_size = np.arange(1, (number_of_electrodes_z*number_of_electrodes_x)+1, 1)
        zeros_array = np.zeros(len(array_size))
        array_size_x = np.arange(0, number_of_electrodes_z*number_of_electrodes_x, number_of_electrodes_x)
        array_size_x = np.append(array_size_x, zeros_array)
        
        ### Plot the simulations for each motor unit as an array 
        fig5 = plt.figure(figsize = (10, 6))
        for i in range(len(array_size)):
            ax = plt.subplot(number_of_electrodes_z , number_of_electrodes_x, array_size[i])
            plt.subplots_adjust(wspace = 0.0, hspace = 0.0)
            ax.grid(which = 'both', ls = 'dashed')
            plt.plot(time_array, normalized_simulation[i, :])
            plt.xlim(time_array[0], time_array[-1] - 1)
            if i < len(array_size) - number_of_electrodes_x:
                ax.xaxis.set_major_formatter(NullFormatter())
            plt.ylim=(y_limit_minimum,y_limit_maximum)
            ax.yaxis.set_major_formatter(NullFormatter())
            if i == 0:
                ax.set_ylabel(1, rotation = 0, ha = 'center', va = 'center', fontsize = 15)
            for j in range(i):
                if i == array_size_x[j]:
                    ax.set_ylabel(array_size[j], rotation = 0, ha = 'center', va = 'center', fontsize = 15)
                elif number_of_electrodes_x == 1:
                    ax.set_ylabel(array_size[j]+1, rotation = 0, ha = 'center', va = 'center', fontsize = 15)
        plt.suptitle('The Surface Electromyography Signal Array', fontsize = 18, fontweight = 'bold')
        
        if number_of_electrodes_x > 1:
            fig5.supxlabel('Time (s)\n Electrodes in the x direction, i.e. vertically across the fibre')
        else:
            fig5.supxlabel('Time (s)')
        if number_of_electrodes_z > 1:
            fig5.supylabel('Normalized sEMG Signal\n Electrodes in the z direction, i.e. along the fibre', ha = 'center', va = 'center')
        else: 
            fig5.supylabel('Normalized sEMG Signal', ha = 'center', va = 'center')
        
        # number_of_motor_units = self.number_of_motor_units
        # Set the desired resolution
        plt.savefig('muap_array.png', dpi = 600)
        
        return plt.show()

    #########################  5  #########################   Plot Suface Electromyography Array without Noise  ##########################    #######################
    def plot_suface_emg_array_no_noise(self):
        """Plots the sEMG array without the added noise.
        
        Arguments:
          simulations
          time_array 
          y_limit_minimum
          y_limit_maximum
          number_of_electrodes_z
          number_of_electrodes_x
        
        Returns:
          Plot of surface EMG without noise
        """

        ### Default arguments:
        # simulations = self.caculate_surface_emg()
        simulations = self.simulations
        time_array = self.time_array
        y_limit_minimum = self.y_limit_minimum
        y_limit_maximum = self.y_limit_maximum
        number_of_electrodes_z = self.electrodes_in_z
        number_of_electrodes_x = self.electrodes_in_x
                
        ### Plot the normalized motor unit action potential
        normalized_simulation = simulations # electrode_sum
        normalized_simulation = (normalized_simulation - normalized_simulation.mean()) / (normalized_simulation.max() - normalized_simulation.min())
        
        # The single fibre action potentials recorded by the electrodes positioned along the length of the fibre.
        array_size = np.arange(1, (number_of_electrodes_z*number_of_electrodes_x)+1, 1)
        zeros_array = np.zeros(len(array_size))
        array_size_x = np.arange(0, number_of_electrodes_z*number_of_electrodes_x, number_of_electrodes_x)
        array_size_x = np.append(array_size_x, zeros_array)
        
        ### Plot the simulations for each motor unit as an array 
        fig5 = plt.figure(figsize = (10, 6))
        for i in range(len(array_size)):
            ax = plt.subplot(number_of_electrodes_z , number_of_electrodes_x, array_size[i])
            plt.subplots_adjust(wspace = 0.0, hspace = 0.0)
            ax.grid(which = 'both', ls = 'dashed')
            plt.plot(time_array, normalized_simulation[i, :])
            plt.xlim(time_array[0], time_array[-1] - 1)
            if i < len(array_size) - number_of_electrodes_x:
                ax.xaxis.set_major_formatter(NullFormatter())
            plt.ylim=(y_limit_minimum,y_limit_maximum)
            ax.yaxis.set_major_formatter(NullFormatter())
            if i == 0:
                ax.set_ylabel(1, rotation = 0, ha = 'center', va = 'center', fontsize = 15)
            for j in range(i):
                if i == array_size_x[j]:
                    ax.set_ylabel(array_size[j], rotation = 0, ha = 'center', va = 'center', fontsize = 15)
                elif number_of_electrodes_x == 1:
                    ax.set_ylabel(array_size[j]+1, rotation = 0, ha = 'center', va = 'center', fontsize = 15)
        plt.suptitle('The Surface Electromyography Signal Array', fontsize = 18, fontweight = 'bold')
        
        if number_of_electrodes_x > 1:
            fig5.supxlabel('Time (s)\n Electrodes in the x direction, i.e. vertically across the fibre')
        else:
            fig5.supxlabel('Time (s)')
        if number_of_electrodes_z > 1:
            fig5.supylabel('Normalized sEMG Signal\n Electrodes in the z direction, i.e. along the fibre', ha = 'center', va = 'center')
        else: 
            fig5.supylabel('Normalized sEMG Signal', ha = 'center', va = 'center')
        
        number_of_motor_units = self.number_of_motor_units
        # Set the desired resolution
        plt.savefig('sEMG_electrode_array_without_noise_{}MUs_{}X{}.png'.format(number_of_motor_units,number_of_electrodes_z,number_of_electrodes_x), dpi = 600)
        
        return plt.show()
 
    #########################  6  #########################   Plot Suface Electromyography Array with Noise  ##########################    #######################
    def plot_suface_emg_array(self):
        """Plots the sEMG array with added noise.
    
        Arguments:
          simulations
          time_array 
          y_limit_minimum
          y_limit_maximum
          number_of_electrodes_z
          number_of_electrodes_x
    
        Returns:
          Plot of surface array EMG with added noise.
        """

        ### Default arguments:
        # simulations = self.simulate_surface_emg()
        simulations = self.simulations
        time_array = self.time_array
        y_limit_minimum = self.y_limit_minimum
        y_limit_maximum = self.y_limit_maximum
        number_of_electrodes_z = self.electrodes_in_z
        number_of_electrodes_x = self.electrodes_in_x
        
        ### Plot the normalized motor unit action potential
        normalized_simulation = simulations
        # normalized_simulation = (normalized_simulation - normalized_simulation.mean()) / (normalized_simulation.max() - normalized_simulation.min())
        
        # The single fibre action potentials recorded by the electrodes positioned along the length of the fibre.
        array_size = np.arange(1, (number_of_electrodes_z*number_of_electrodes_x)+1, 1)
        zeros_array = np.zeros(len(array_size))
        array_size_x = np.arange(0, number_of_electrodes_z*number_of_electrodes_x, number_of_electrodes_x)
        array_size_x = np.append(array_size_x, zeros_array)
        
        ### Plot the simulations for each motor unit as an array 
        fig6 = plt.figure(figsize = (10, 6))
        for i in range(len(array_size)):
          ax = plt.subplot(number_of_electrodes_z , number_of_electrodes_x, array_size[i])
          plt.subplots_adjust(wspace = 0.0, hspace = 0.0)
          ax.grid(which = 'both', ls = 'dashed')
          plt.plot(time_array, normalized_simulation[i, :])
          plt.xlim(time_array[0], time_array[-1] - 1)
          if i < len(array_size) - number_of_electrodes_x:
              ax.xaxis.set_major_formatter(NullFormatter())
          plt.ylim(y_limit_minimum,y_limit_maximum)
          ax.yaxis.set_major_formatter(NullFormatter())
          if i == 0:
              ax.set_ylabel(1, rotation = 0, ha = 'center', va = 'center', fontsize = 15)
          for j in range(i):
            if i == array_size_x[j]:
                ax.set_ylabel(array_size[j], rotation = 0, ha = 'center', va = 'center', fontsize = 15)
            elif number_of_electrodes_x == 1:
                ax.set_ylabel(array_size[j]+1, rotation = 0, ha = 'center', va = 'center', fontsize = 15)
        plt.suptitle('The Surface Electromyography Signal Array', fontsize = 20, fontweight = 'bold')
        
        if number_of_electrodes_x > 1:
            fig6.supxlabel('Time (s)\n Electrodes in the x direction, i.e. vertically across the fibre')
        else:
            fig6.supxlabel('Time (s)')
        if number_of_electrodes_z > 1:
            fig6.supylabel('Normalized sEMG Signal\n Electrodes in the z direction, i.e. along the fibre', ha = 'center', va = 'center')
        else: 
            fig6.supylabel('Normalized sEMG Signal', ha = 'center', va = 'center')
        
        number_of_motor_units = self.number_of_motor_units
        # Set the desired resolution
        plt.savefig('sEMG_electrode_array_{}MUs_{}X{}.png'.format(number_of_motor_units,number_of_electrodes_z,number_of_electrodes_x), dpi = 600)
        
        return plt.show()

    #########################  7  #########################  Plot Saved Surface Electromyography Array without Noise  ##########################    #######################
    def plot_one_electrode_surface_emg_no_noise(self):
        """
        Plots the sEMG from selected electrode without added noise.
        
        Arguments:
          simulation_time
          sampling_rate
          surface_emg
          electrodes_in_z
          electrodes_in_x 
        
        Returns:
          Plot of surface EMG from selected elctrode without added noise.
        """
        
        ### Default arguments:
        simulation_time = self.simulation_time
        sampling_rate = self.sampling_rate
        surface_emg = self.caculate_surface_emg()
        electrodes_in_z = self.electrodes_in_z
        electrodes_in_x = self.electrodes_in_x
        number_of_motor_units = self.number_of_motor_units
        
        electrod_postion = electrodes_in_z * electrodes_in_x
        
        time_array = np.linspace(0, simulation_time, simulation_time*sampling_rate) 
        
        fig7 = plt.figure(7)
        ### Plot the simulations for each motor unit after sum
        electrod_one_sum = np.zeros(len(time_array))
          
        for m, simulation in enumerate(surface_emg):
            electrod_one_sum += simulation[electrod_postion-1,:]
        
        plt.plot(time_array, electrod_one_sum*10**3) # Plot the electrode row postion with m numbers of motor units.
        
        plt.xlabel('Time (s)')
        plt.ylabel('Amplitude (mV)')
        fig7.suptitle('sEMG Signal for One Electrode', fontweight = 'bold')
        
        # Set the desired resolution
        plt.savefig('sEMG_one_electrode_wihout_noise_{}MUs_{}X{}.png'.format(number_of_motor_units,electrodes_in_z,electrodes_in_x), dpi = 600)
        
        return plt.show()

    #########################  8  #########################  Plot Saved Surface Electromyography Array with Noise  ##########################    #######################
    def plot_one_electrode_surface_emg(self):
        """
        Plots the sEMG from selected electrode with added noise.
    
        Arguments:
            simulation_time
            sampling_rate
            surface_emg
            electrodes_in_z
            electrodes_in_x 
    
        Returns:
            Plot of surface EMG from selected elctrode with added noise.
        """
    
        ### Default arguments:
        simulation_time = self.simulation_time
        sampling_rate = self.sampling_rate
        surface_emg = self.simulate_surface_emg()
        electrodes_in_z = self.electrodes_in_z
        electrodes_in_x = self.electrodes_in_x
        number_of_motor_units = self.number_of_motor_units
        
        electrod_postion = electrodes_in_z * electrodes_in_x
        
        time_array = np.linspace(0, simulation_time, simulation_time*sampling_rate) 
        
        fig8 = plt.figure(8)
        
        plt.plot(time_array, surface_emg[electrod_postion-1, :]*10**3) # Plot the electrode row postion with m numbers of motor units.
        
        plt.xlabel('Time (s)')
        plt.ylabel('Amplitude (mV)')
        fig8.suptitle('sEMG Signal for One Electrode', fontweight = 'bold')
        
        # Set the desired resolution
        plt.savefig('sEMG_one_electrode_{}MUs_{}X{}.png'.format(number_of_motor_units,electrodes_in_z,electrodes_in_x), dpi = 600)
        
        return plt.show()

    #########################  9  #########################  Subplot Saved Surface Electromyography Array with Noise  ##########################    #######################
    def subplot_one_electrode_surface_emg(self):
        """
        Plots the sEMG from selected electrode with added noise.
    
        Arguments:
          simulation_time
          sampling_rate
          surface_emg
          electrodes_in_z
          electrodes_in_x 
    
        Returns:
          Plot of surface EMG from selected elctrode with added noise.
        """
        ### Default arguments:
        simulation_time = self.simulation_time
        sampling_rate = self.sampling_rate
        surface_emg = self.simulate_surface_emg()
        electrodes_in_z = self.electrodes_in_z
        electrodes_in_x = self.electrodes_in_x
        time_start = self.time_start
        time_end = self.time_end
        amplitude_start = self.amplitude_start
        amplitude_end = self.amplitude_end
        number_of_motor_units = self.number_of_motor_units
          
        electrod_postion = electrodes_in_z * electrodes_in_x
        
        time_array = np.linspace(0, simulation_time, simulation_time*sampling_rate) 
        
        fig9 = plt.figure(9)
        plt.subplot(2,1,1)
        plt.plot(time_array, surface_emg[electrod_postion-1, :]*10**3) # Plot the electrode row postion with m numbers of motor units.
        
        plt.subplot(2,1,2)
        plt.plot(time_array, surface_emg[electrod_postion-1, :]*10**3)
        plt.xlim(time_start, time_end)
        plt.ylim(amplitude_start, amplitude_end)
        fig9.supxlabel('Time (s)', fontsize = 15)
        fig9.supylabel('Amplitude (mV)', fontsize = 15) # µ
        fig9.suptitle('sEMG Signal for One Electrode', fontsize = 20, fontweight = 'bold')
        
        # Set the desired resolution
        plt.savefig('sEMG_subplot_one_electrode_{}MUs_{}X{}.png'.format(number_of_motor_units,electrodes_in_z,electrodes_in_x), dpi = 600)
        
        return plt.show()

#  #########################    #########################               ##########################    #######################
                                                           # THE END #
#  #########################    #########################               ##########################    #######################
